var f=Object.defineProperty;var m=(c,t,e)=>t in c?f(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var u=(c,t,e)=>m(c,typeof t!="symbol"?t+"":t,e);class o{static hydrate(t={}){if(!(!t||typeof t!="object"))for(const e in t)Object.prototype.hasOwnProperty.call(t,e)&&this.set(e,t[e])}static ensureModel(t){this.registry[t]||(this.registry[t]={})}static set(t,e={}){if(!(!t||typeof t!="string"||!e)){this.ensureModel(t);for(const r in e){if(!Object.prototype.hasOwnProperty.call(e,r))continue;const i=e[r]||{},n=this.registry[t][r]||{},a={...n,...i};if(typeof a.max!="number"){const s=Number(a.max??i.max??n.max??0);a.max=Number.isNaN(s)?0:s}if(typeof a.active!="number"){const s=Number(i.active??n.active??0);a.active=Number.isNaN(s)?0:s}typeof a.max=="number"&&typeof a.active=="number"&&(a.remaining=Math.max(0,a.max-a.active)),this.registry[t][r]=a}}}static list(t){var r;if(!t)return[];const e=((r=this.registry)==null?void 0:r[t])??{};return Object.keys(e).map(i=>({field:i,...e[i]}))}static get(t,e){var r,i;return!t||!e?null:((i=(r=this.registry)==null?void 0:r[t])==null?void 0:i[e])??null}static has(t,e){return!!this.get(t,e)}static canEnable(t,e,r=!1){const i=this.get(t,e);return!i||r||typeof i.max!="number"||i.max<=0||typeof i.active!="number"?!0:i.active<i.max}static shouldBlock(t,e,r=!1){return!this.canEnable(t,e,r)}static getMessage(t,e){var r;return((r=this.get(t,e))==null?void 0:r.message)??null}static updateFromServer(t,e){if(!t||!e)return;const{field:r,limit:i}=e;if(!r||!i)return;this.ensureModel(t);const n=this.registry[t][r]||{},a={...n,...i};if(typeof a.max!="number"){const s=Number(a.max??i.max??n.max??0);a.max=Number.isNaN(s)?0:s}if(typeof a.active!="number"){const s=Number(i.active??n.active??0);a.active=Number.isNaN(s)?0:s}typeof a.max=="number"&&typeof a.active=="number"&&(a.remaining=Math.max(0,a.max-a.active)),this.registry[t][r]=a}static bulkUpdate(t,e=[]){!t||!Array.isArray(e)||(this.ensureModel(t),e.forEach(({field:r,limit:i})=>{if(!r||!i)return;const n=this.registry[t][r]||{},a={...n,...i};if(typeof a.max!="number"){const s=Number(a.max??i.max??n.max??0);a.max=Number.isNaN(s)?0:s}if(typeof a.active!="number"){const s=Number(i.active??n.active??0);a.active=Number.isNaN(s)?0:s}typeof a.max=="number"&&typeof a.active=="number"&&(a.remaining=Math.max(0,a.max-a.active)),this.registry[t][r]=a}))}static applyChange(t,e,{previous:r,next:i}){const n=this.get(t,e);!n||typeof n.max!="number"||(typeof n.active!="number"&&(n.active=0),r!==i&&(i?n.active=Math.min(n.max,n.active+1):r&&(n.active=Math.max(0,n.active-1)),n.remaining=Math.max(0,n.max-n.active)))}static remaining(t,e){const r=this.get(t,e);return r?typeof r.remaining=="number"?r.remaining:typeof r.max=="number"&&typeof r.active=="number"?Math.max(0,r.max-r.active):null:null}}u(o,"registry",{});export{o as B};
